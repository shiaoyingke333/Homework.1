# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19LkZPslDZQz_8pioqYk80yt1kzlCUHLt
"""

def compute(a,b,c):
  q=(b**2-4*a*c)**(0.5)
  return (-b+q)/(2*a), (-b-q)/(2*a)

a=eval(input())
b=eval(input())
c=eval(input())
print(compute(a,b,c))



import itertools

# Define the logical operations
def logical_and(p, q):
    return p and q

def logical_or(p, q):
    return p or q

def logical_xor(p, q):
    return p != q

def logical_implies(p, q):
    return (not p) or q

def logical_iff(p, q):
    return p == q

# Generate all possible combinations of truth values for P and Q
truth_values = list(itertools.product([False, True], repeat=2))

# Create the header for the truth table
header = ["P", "Q", "P ∧ Q", "P ∨ Q", "P ⊕ Q", "P → Q", "P ← Q", "P ↔ Q"]
print("\t".join(header))

# Generate and print the truth table rows
for p, q in truth_values:
    row = [p, q, logical_and(p, q), logical_or(p, q), logical_xor(p, q), logical_implies(p, q), logical_implies(q, p), logical_iff(p, q)]
    print("\t".join(map(str, row)))

row = "{:^10}{:^10}{:^10}{:^10}{:^10}{:^10}{:^10}"
print(row.format("P", "Q", "P ∧ Q", "P ∨ Q", "P ⊕ Q", "P → Q", "P ← Q", "P ↔ Q"))
print(row.format("F", "F", "F", "F", "F", "F", "T", "T"))
print(row.format("F", "T", "F", "T", "T", "T", "T", "F"))
print(row.format("T", "F", "F", "T", "T", "F", "F", "T"))
print(row.format("T", "T", "T", "T", "F", "F", "T", "T"))